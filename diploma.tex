%TODO: в конечной версии draft заменить final
\documentclass[oneside, draft, 14pt, a4paper]{extreport}
\renewcommand{\rmdefault}{ftm} % Times New Roman

\usepackage[utf8]{inputenc}
\usepackage[russianb]{babel}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[labelsep = period]{caption}
\usepackage{moreverb}
\usepackage[titletoc]{appendix}

% flowcharts
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,
	decorations.pathreplacing,decorations.pathmorphing}

% landscape orientation
\usepackage{lscape}

% красная строка для всех абзацев
\usepackage{indentfirst}

% отступы
\usepackage{vmargin}
\setmarginsrb{3cm}{2cm}{1.5cm}{2cm}{0pt}{0pt}{0pt}{1.3cm}

% полуторный интервал только для текста
\usepackage{setspace}
\onehalfspacing

% --------------------- определение команд рубрикации ---------------------
\newcommand\Chapter[1]
{\textsl{•}
	\refstepcounter{chapter}
	\chapter*
	{
		\begin{huge}		
			\textbf
			{
				\raggedright \centering
				\chaptername\ \arabic{chapter}. #1\\
			}
		\end{huge}
		\bigskip
	}
	
	\addcontentsline{toc}{chapter}{\arabic{chapter}. #1}
}

\newcommand\Section[1]
{
	\refstepcounter{section}
	\section*
	{
		\raggedright \centering
		\arabic{chapter}. \arabic{section}. #1
	}
	
	\addcontentsline{toc}{section}{\arabic{chapter}. \arabic{section}. #1}
}

\newcommand\Subsection[1]
{
	\refstepcounter{subsection}
	\subsection*
	{
		\raggedright \centering
		\arabic{chapter}. \arabic{section}. \arabic{subsection}. #1		
	}
	
	\addcontentsline{toc}{subsection}{\arabic{chapter}. \arabic{section}.  \arabic{subsection}. #1}
}
% -------------------------------------------------------------------------

% точки в оглавлении
\usepackage{tocstyle}
\usetocstyle{allwithdot}

% точка вместо квадратных скобок в списке литературы
\makeatletter
\renewcommand*{\@biblabel}[1]{\hfill#1.}
\makeatother

%TODO: в конечной версии fussy заменить на sloppy
\fussy

\begin{document}

\renewcommand{\contentsname}{\centering Оглавление}
\tableofcontents
%\enlargethispage{\baselineskip}
\thispagestyle{empty}

\chapter*{\centering Введение}
\addcontentsline{toc}{chapter}{Введение}

\section*{\centering Актуальность}
\addcontentsline{toc}{section}{Актуальность}
Повсеместное внедрение компьютерных сетей, успехи в развитии оптоволоконных и беспроводных средств связи
споровождаются непрерывной сменой сетевых технологий, направленной на повышение быстродействия
и надёжности сетей. Однако создание опытного образца сети для оценки её эффективности не всегда является
оправданным с точки зрения времени и трудоёмкости, поэтому разработка математических моделей является актуальной задачей.

Для непрерывного количественного и качественного роста компьютерных сетей необходимо развитие фундаментальной
теории в этой области и создание инженерных методов анализа, направленных на сокращение сроков и повышение
качества проектирования компьютерных сетей.

В качестве такой теории выступает теория систем и сетей массового обслуживания.
Математические методы этой теории обеспечивают возможность решения многочисленных задач расчёта
характеристик качества функционирования различных компонентов компьютерных сетей.

\section*{\centering Цель}
\addcontentsline{toc}{section}{Цель}
В данной работе рассматривается анализ критериев времени и надёжности доставки информации в информационно-вычислительных
сетях (ИВС) большой размерности различных топологий с множественным методом доступа без коллизий,
построенных на основе технологий семейства Ethernet.

\section*{\centering Задачи}
\addcontentsline{toc}{section}{Задачи}
В задачи исследования входит:
\begin{enumerate}
	\item Изучение методики разработки моделей сетей.
	\item Разработка аналитических математических моделей ИВС.
	\item Разработка программы для вычисления стационарных и интегральных вероятностных характеристик заданной ИВС.
	\item Проведение модельного эксперимента.
\end{enumerate}

\section*{\centering Методы}
\addcontentsline{toc}{section}{Методы}
Модельный эксперимент и математические модели фрагментов сетей основываются на математическом аппарате и методах теории
систем и сетей массового обслуживания.

\section*{\centering Значимость}
\addcontentsline{toc}{section}{Значимость}
Разработанная программа автоматизирует рутинную работу по вычислению стационарных и интегральных вероятностных характеристик.
Она будет полезна при:
\begin{itemize}
	\item[-] предварительной оценке характеристик проектируемой ИВС
	\item[-] оценке характеристик уже существующих ИВС
	\item[-] изучении влияния изменений топологии и/или оборудования на характеристики ИВС
\end{itemize}

\Chapter{Теоретичские основы разработки математической модели ИВС}
\Section{Однородные экспоненциальные сети}
Предметом изучения сетей массового обслуживания (СеМО) являются методы количественного анализа очередей при взаимодействии
множества центров обслуживания и потоков сообщений.

СеМО представляет собой совокупность конечного числа \( M \) обслуживающих центров, в которой циркулируют сообщения,
переходящие в соответствии с маршрутной матрицей (см. \ref{subsection:routingMatrix})  из одного центра сети в другой.
Центром обслуживания является система массвого обслуживания, состоящую из \( A \; (1 \leqslant A \leqslant \infty) \) одинаковых приборов
и буфера объёмом \( C \; (0 \leqslant C \leqslant \infty) \). Если в момент поступления сообщения все обслуживающие приборы центра заняты, то сообщение занимает очередь в буфере и ожидает обслуживания \cite[стр. ~90]{vishnevsky}.

В дальнейшем будем полагать, что объём буфера в центре обслуживания \( C = \infty \), время обслуживания заявок распределено по экспоненциальному закону, а распределение входящего потока имеет распределение Пуассона.

СеМО с такими распределениями длительности обслуживания и входящего потока являются однородными экспоненциальными сетями
или сетями Джексона \cite[стр. ~94]{vishnevsky}. Такая модель даёт верхнюю границу оценки (худший вариант)
и стационарные вероятности состояний сети имеют мультипликативную форму.

В данной работе используются открытые сети Джексона, обрабатывающие \( F \) входящих потоков. В открытую сеть сообщения поступают из внешнего источника,
могут покидать сеть после завершения обслуживания и интенсивность входного потока не зависит от состояния сети.

\Subsection{Пуассоновский поток}
Предположение о том, что входящий поток является Пуассоновским, значительно облегчает математические выкладки при достаточной точности.
%\clearpage

\noindent Пуассоновский поток имеет следующие свойства \cite[стр. ~12]{hinchin}:
\begin{enumerate}
	\item Стационарность --- вероятность появления \( k \) событий на любом промежутке времени зависит только от числа \( k \) и от длительности
	\( t \) промежутка.
	
	\item Ординарность --- вероятность наступления за элементарный промежуток времени более одного события мала по сравнению с вероятностью
	наступления за этот промежуток не более одного события и ей можно пренебречь.
	
	\item Независимость --- вероятность появления \( k \) на любом промежутке времени не зависит от того, появлялись или не появлялись
	события в моменты времени, предшествующие началу рассматриваемого промежутка.
\end{enumerate}

\Subsection{Маршрутная матрица}
\label{subsection:routingMatrix}
Маршрутная матрица задаёт структуру соединений узлов сети (топологию) и вероятности переходов сообщения из одного центра сети, после завершения обслуживания
в нём, в другой.
Для открытой сети в качестве внешнего источника вводится новый центр с индексом \( 0 \).
Таким образом маршрутная матрица имеет вид \( P = \: \parallel P_{ij} \parallel \),
где \cite[стр. ~17]{klimanov:manual}:
\\ \( i, j = \overline{0, n}, \: n \) - число узлов в сети,
\\ \( P_{0j} \) - вероятность поступления сообщения в \( M_j \) узел сети из внешнего источника,
\\ \( P_{i0} \) - вероятность покидания сообщением сети после окончания обработки в \( M_i \) узле,
\\ \( P_{ij} \) - вероятность перехода сообщения в узел \( M_j \) после обработки в узле \( M_i \).
\\ \( P_{00} = 0\).

\noindent В маршрутной матрице должно выполняться равенство \( \sum\limits_{j = 0}^{n} P_{ij} = 1, \: i = \overline{1, n} \).
Т.е. событие, состоящие в том, что сообщение после обработки в узле сети перейдёт в другой узел или покинет сеть --- достоверное.

Для сети, обрабатывающей \( F \) входящих потоков, необходимо задать \( F \) маршрутных матриц \( P^{m}, \: m = \overline{1, F} \) для каждого входного потока.

\Section{Методика разработки математической модели ИВС}
\label{section:mathmodel}
Одним из самых распространнёных методов для разработки аналитической математической модели ИВС является приближённая
декомпозиционная модель сети массового обслуживания, основанная на составлении уравнений баланса средних для класса мультипликативных сетей.
Эта модель допускает простую декомпозицию всей сети на отдельные элементы и обратную операцию - композицию. Такой подход позволяет проводить
анализ каждого фрагмента сети независимо, а затем объединять эти фрагменты, получая обобщённые характеристики.

Первый этап методики состоит в декомпозиции сети на отдельные фрагменты. В зависимости от уровня детализации выделяют 4 уровня декомпозиции:
\begin{enumerate}
	\item Состоит из набора функциональных элементов (терминалов, моноканалов, канальных станций), каждый из которых может быть представлен
	в виде отдельной СМО. Самый подробный уровень декомпозиции.	
	\item Учитывает особенности взаимодействия отдельных элементов 1-го уровня в пределах всей ИВС.
	\item Учитывает взаимодействие нескольких ИВС элементарных топологий (физическая шина, физическое кольцо), связанных между собой в единую ИВС
	простой топологии (дерево, звезда, и т.д.).
	\item Учитывает взаимодействие любых ИВС 2-го и 3-го уровня, связанных в единую ИВС произвольной топологии.
\end{enumerate}
Декомпозиция позволяет преодолеть трудности анализа ИВС большой размерности за счёт разделения ИВС на иерархический набор более простых моделей \cite[стр. ~11]{klimanov:thesis}

Второй этап методики независимо от уровня декомпозиции заключается в разработке отдельных математических моделей всех составляющих на всех уровнях декомпозиции
и состоит из следующих подэтапов:
\begin{enumerate}
	\item  Составление уравнений баланса интенсивностей потоков.
	\item  Вычислеие коэффициентов передачи из уравнений баланса.
	\item  Вычисление стационарных вероятностно-временных характеристик (ВВХ) для каждого отдельного элемента СеМО.
	\item  Вычисиление интегральных ВВХ при взаимодействии двух любых абонентов сети.
\end{enumerate}

Исходными параметрами модели являются интенсивности обслуживающих узлов сети \( \mu_{i}^{m} \), интенсивности поступления сообщений из внешнего источника
\( \lambda_{i}^{m} \) и маршрутная матрица \( P^{m} \) для каждого входного потока \( m = \overline{1, F} \).

\Subsection{Уравнения баланса}
\label{subsection:balanceEquations}
Уравнения баланса позволяют найти общие интенсивности потоков \( \lambda_{i}^{'m} \) сообщений в стационарном режиме открытой СеМО (стационарным режимом называется состояние сети,
при \( t \rightarrow \infty \) и \( \rho \leqslant 1 \) (см. \ref{subsection:coefficientOfLoading})).

\[ \lambda_{i}^{'m} = e_{i}^{m} \lambda_{0}^{m} \]
\( e_{i}^{m} \) - коэффициенты передачи, получаемые при решении уравнений баланса,
\( \lambda_{0}^{m} = \sum\limits_{i = 1}^{n} \lambda_{i}^{m}\) - суммарная интенсивность всех внешних потоков типа \( m \).

Общая интенсивность птоков складывается из интенсивностей поступления сообщений в \( M_{i} \) узел из внешнего источника \( P_{0i}^{m} \lambda_{0}^{m}, P_{0i}^{m} = \frac{\lambda_{j}^{m}}{\lambda_{0}^{m}} \)
и интенсивностей поступления сообщений от других узлов \( e_{j}^{m} P_{ji}^{m} \lambda_{0}^{m} \) \cite[стр. ~17]{klimanov:manual}.

\[ e_{i}^{m} \lambda_{0}^{m} = P_{0i}^{m} \lambda_{0}^{m} + \sum\limits_{j = 1}^{n} e_{j}^{m} P_{ji}^{m} \lambda_{0}^{m}, i = \overline{1, n}, m = \overline{1, F} \]

\noindent Видно, что можно сократить обе части уравнения на \( \lambda_{0}^{m} \).

\[ e_{i}^{m} = P_{0i}^{m} + \sum\limits_{j = 1}^{n} e_{j}^{m} P_{ji}^{m}, i = \overline{1, n}, m = \overline{1, F} \]

\[ \Updownarrow \]

\[
 	\left\{
		\begin{aligned}
			& e_{1}^{m} = P_{01}^{m} + e_{1}^{m} P_{11}^{m} + \cdots + e_{n}^{m} P_{n1}^{m} \\
			& \vdots \\
			& e_{n}^{m} = P_{0n}^{m} + e_{1}^{m} P_{1n}^{m} + \cdots + e_{n}^{m} P_{nn}^{m}
		\end{aligned}
	\right.
\]

\noindent После решения этой системы уравнений получаем \( e_{i}^{m} \) для каждого узла, что позволяет рассчитать \( \lambda_{i}^{'m} \).

\Subsection{Коэффициент загрузки}
\label{subsection:coefficientOfLoading}
Коэффициент загрузки для узла \( M_{i} \) вычисляется по формуле
\[ \rho_{i} = \sum\limits_{m = 0}^{F} \rho_{i}^{m}, \: \rho_{i}^{m} = \frac{\lambda_{i}^{'m}}{\mu_{i}^{m}}, \:
i = \overline{1, n} \]
\( \rho_{i}^{m} \)- коэффициент использования узла, характеризующий соотношение интенсивности входящего потока к интенивности обработки \cite[стр. ~34]{kleinrock:qs}. \\
Для существования стационарного распределения числа сообщений в системе необходимо выполнение условия
\[ 0 \leqslant \rho_{i}, \rho_{i}^{m} \leqslant 1, \: i = \overline{1, n} \]
что согласуется с интуитивными соображениями: для того, чтобы в системе не накапливалась бесконечная очередь, необходимо, чтобы в среднем сообщения в системе обслуживались быстрее, чем они туда поступают \cite[стр. ~35]{vishnevsky}.

\Subsection{Стационарные вероятностно-временные характеристики}
Для каждого узла  \( M_{i} \) сети определяются четыре вероятностно-временные характеристики \cite[стр. ~19]{klimanov:manual}:
\begin{enumerate}
	\item Средняя длительность ожидания обслуживания.
	\[
		W_{i} = \frac{ \frac{1}{2} \sum\limits_{m = 0}^{F} \frac{ \rho_{i}^{m} (1 + V_{i}^{m^{2}}) }{ \mu_{i}^{m}} }{ 1 - \rho_{i} }
		= \Biggl\lvert \begin{aligned} & V_{i}^{m} = 1 \\ & \text{для распределения Пуассона} \end{aligned} \Biggr\rvert
		= \frac{ \sum\limits_{m = 0}^{F} \frac{ \rho_{i}^{m} }{ \mu_{i}^{m}} }{ 1 - \rho_{i} }
	\]
	\( V_{i}^{m} \) - коэффициент вариации времени обработки.
	
	\item Средняя длительность пребывания сообщения в узле для потока \( m \).
	\[ U_{i}^{m} = W_{i} + \frac{1}{\mu_{i}^{m}} \]
	\( \frac{1}{\mu_{i}^{m}} \) - время обработки сообщения.
	
	\item Средняя длина очереди сообщений в узле для потока \( m \).
	\[ L_{i}^{m} = \lambda_{i}^{'m} W_{i} \]
	
	\item Среднее число сообщений в узле для потока \( m \), хакатеризующее количество сообщений, находящихся в очереди на обработку,
	и количество сообщений, обрабатывающихся в узле.
	\[ N_{i}^{m} = \lambda_{i}^{'m} U_{i}^{m} \]
\end{enumerate}
Эти формулы справедливы для многих моделей СМО и называются формулами Литтла \cite[стр. ~37]{vishnevsky}.

\Subsection{Интегральные вероятностно-временные характеристики}
\label{subsection:iptc}
Для определения интегральных ВВХ используются стационарные ВВХ, полученные для каждого узла сети, и анализ маршрутов движения сообщений между двумя абнентами
\( A_{i} \) и \( A_{j}, \: i \neq j \).

Любой маршрут между двумя любыми абонентами принадлежит к одному из трёх типов:
\begin{enumerate}
	\item Последовательная обработка сообщений на конечном числе элементов сети.
	\begin{figure}[h!]
		\begin{center}
			\begin{picture}(200, 20)(-10, -10)
				\put(0, 0){\circle{20}}
				\put(-5, -3){\begin{scriptsize} 1 \end{scriptsize}}
	
				\put(10, 0){\vector(1, 0){20}}
				
				\put(40, 0){\circle{20}}
				\put(35, -3){\begin{scriptsize} 2 \end{scriptsize}}
		
				\put(50, 0){\vector(1, 0){20}}
				
				\put(78, -1){\( \dots \)}

				\put(102, 0){\vector(1, 0){20}}
				
				\put(132, 0){\circle{20}}
				\put(119.5, -3){\begin{scriptsize} \( n - 1 \)\end{scriptsize}}
				
				\put(142, 0){\vector(1, 0){20}}
				
				\put(172, 0){\circle{20}}
				\put(166.5, -2.5){\begin{scriptsize} \( n \)\end{scriptsize}}
			\end{picture}
		\end{center}

	\caption{Последовательная обработка}
	\label{pic:sequence}
	\end{figure}
	
	Маршрут состоит из последовательно соединённых узлов сети (рис. \ref{pic:sequence}). Интегральные характеристики маршрута вычисляются как сумма
	соответсвующих характеристик узлов, входящих в маршрут. \\
	Среднее время ожидания обслуживания в маршруте.
	\[ W = \sum\limits_{i = 1}^{n} W_{i} \]
	Среднее время пребывания требования в маршруте для потока \( m \).
	\[ U^{m} = \sum\limits_{i = 1}^{n} U_{i}^{m} \]
	Средняя длина очереди требований в маршруте для потока \( m \).
	\[ L^{m} = \sum\limits_{i = 1}^{n} L_{i}^{m} \]
	Среднее число требований в маршруте для потока \(	m \).
	\[ N^{m} = \sum\limits_{i= 1}^{n} N_{i}^{m} \]
	
	\item Параллельные варианты обработки с определёнными значениями вероятности выбора рассматриваемого варианта.
	\begin{figure}[h!]
		\begin{center}
			\begin{picture}(220, 120)
				\put(10, 50){\circle{20}}
				\put(5.5, 47){\begin{scriptsize} \( i \) \end{scriptsize}}
				
				\put(70, 100){\begin{scriptsize} \( \beta_{1} \) \end{scriptsize}}
				\put(20, 50){\vector(4, 3){80}}
				
				\put(110, 110){\circle{20}}
				\put(105, 107){\begin{scriptsize} 1 \end{scriptsize}}
				
				\put(120, 110){\vector(4, -3){80}}
				
				\put(70, 70){\begin{scriptsize} \( \beta_{2} \) \end{scriptsize}}
				\put(20, 50){\vector(4, 1){80}}
				
				\put(110, 70){\circle{20}}
				\put(105, 67){\begin{scriptsize} 2 \end{scriptsize}}
				
				\put(120, 70){\vector(4, -1){80}}
				
				\put(20, 50){\vector(4, -1){80}}				
				\put(108, 35){\( \vdots \)}
				
				\put(70, 25){\begin{scriptsize} \( \beta_{l} \) \end{scriptsize}}
				\put(20, 50){\vector(2, -1){80}}
				
				\put(110, 10){\circle{20}}
				\put(105.5, 7){\begin{scriptsize} \( l \) \end{scriptsize}}
				
				\put(120, 10){\vector(2, 1){80}}
				
				\put(210, 50){\circle{20}}
				\put(205.5, 47){\begin{scriptsize} \( j \) \end{scriptsize}}
			\end{picture}
		\end{center}

	\caption{Параллельные варианты}
	\label{pic:parallel}
	\end{figure}
	
	Маршрут зависит от одного из выбранного параллельного варианта (рис. \ref{pic:parallel}). Заданы параллельные варианты обработки с вероятностями выбора
	(см. \ref{subsection:pathsProbabilities}) \( \beta_{k}, \: k = \overline{1, l}, \: l \) - количество альтернатив и должно выполняться нормирующее условие
	\( \sum\limits_{k = 1}^{l} \beta_{k} = 1 \).
	
	Интегральные ВВХ определяются следующим образом. \\
	Среднее время ожидания обслуживания в маршруте.
	\[ W = W_{i} + \sum\limits_{k = 1}^{l} \beta_{k} W_{k} + W_{j} \]
	Среднее время пребывания требования в маршруте для потока \( m \).
	\[ U^{m} = U_{i}^{m} + \sum\limits_{k = 1}^{l} \beta_{k} U_{k}^{m} + U_{j}^{m} \]
	Средняя длина очереди требований в маршруте для потока \( m \).
	\[ L^{m} = L_{i}^{m} + \sum\limits_{k = 1}^{l} \beta_{k} L_{k}^{m} + L_{j}^{m} \]
	Среднее число требований в маршруте для потока \( m \).
	\[ N^{m} = N_{i}^{m} + \sum\limits_{k = 1}^{l} \beta_{k} N_{k}^{m} + N_{j}^{m} \]
	
	\item Комбинация первых двух типов.
	\begin{figure}[h!]
		\begin{center}
			\begin{picture}(382, 120)
				\put(10, 50){\circle{20}}
				\put(5.5, 47){\begin{scriptsize} \( i \) \end{scriptsize}}
				
				\put(70, 100){\begin{scriptsize} \( \beta_{1} \) \end{scriptsize}}
				\put(20, 50){\vector(4, 3){80}}
				
				%--------------------------------------------------------------------------
					\put(110, 110){\circle{20}}
					\put(105, 107){\begin{scriptsize} 1 \end{scriptsize}}
	
					\put(120, 110){\vector(1, 0){15}}
				
					\put(145, 110){\circle{20}}
					\put(140, 107){\begin{scriptsize} 2 \end{scriptsize}}
		
					\put(155, 110){\vector(1, 0){15}}

					\put(183, 109){\( \dots \)}

					\put(207, 110){\vector(1, 0){15}}
				
					\put(237, 110){\circle{20}}
					\put(224.5, 107){\begin{scriptsize} \( n - 1 \)\end{scriptsize}}
					
					\put(247, 110){\vector(1, 0){15}}
				
					\put(272, 110){\circle{20}}
					\put(266.5, 107.5){\begin{scriptsize} \( n \)\end{scriptsize}}	
				%--------------------------------------------------------------------------
				
				\put(282, 110){\vector(4, -3){80}}
				
				\put(70, 70){\begin{scriptsize} \( \beta_{2} \) \end{scriptsize}}
				\put(20, 50){\vector(4, 1){80}}
				
				%--------------------------------------------------------------------------					
					\put(110, 70){\circle{20}}
					\put(105, 67){\begin{scriptsize} 1 \end{scriptsize}}
	
					\put(120, 70){\vector(1, 0){15}}
				
					\put(145, 70){\circle{20}}
					\put(140, 67){\begin{scriptsize} 2 \end{scriptsize}}
		
					\put(155, 70){\vector(1, 0){15}}

					\put(183, 69){\( \dots \)}

					\put(207, 70){\vector(1, 0){15}}
				
					\put(237, 70){\circle{20}}
					\put(224.5, 67){\begin{scriptsize} \( n - 1 \)\end{scriptsize}}
					
					\put(247, 70){\vector(1, 0){15}}
				
					\put(272, 70){\circle{20}}
					\put(266.5, 67.5){\begin{scriptsize} \( n \)\end{scriptsize}}					
				%--------------------------------------------------------------------------
				
				\put(282, 70){\vector(4, -1){80}}
				
				\put(20, 50){\vector(4, -1){80}}				
				\put(108, 35){\( \vdots \)}
				
				\put(70, 25){\begin{scriptsize} \( \beta_{l} \) \end{scriptsize}}
				\put(20, 50){\vector(2, -1){80}}
				
				%--------------------------------------------------------------------------					
					\put(110, 10){\circle{20}}
					\put(105, 7){\begin{scriptsize} 1 \end{scriptsize}}
	
					\put(120, 10){\vector(1, 0){15}}
				
					\put(145, 10){\circle{20}}
					\put(140, 7){\begin{scriptsize} 2 \end{scriptsize}}
		
					\put(155, 10){\vector(1, 0){15}}

					\put(183, 9){\( \dots \)}

					\put(207, 10){\vector(1, 0){15}}
				
					\put(237, 10){\circle{20}}
					\put(224.5, 7){\begin{scriptsize} \( n - 1 \)\end{scriptsize}}
					
					\put(247, 10){\vector(1, 0){15}}
				
					\put(272, 10){\circle{20}}
					\put(266.5, 7.5){\begin{scriptsize} \( n \)\end{scriptsize}}					
				%--------------------------------------------------------------------------
				
				\put(282, 10){\vector(2, 1){80}}
				
				\put(372, 50){\circle{20}}
				\put(367.5, 47){\begin{scriptsize} \( j \) \end{scriptsize}}
			\end{picture}
		\end{center}

	\caption{Комбинированный тип обработки}
	\label{pic:combine}
	\end{figure}	
	
	Маршрут зависит от одного из выбранных параллельных маршрутов (рис. \ref{pic:combine}).
	
	Комбинированный тип обработки включает в себя рассмотрение сложных альтернатив, представляющих собой конечную комбинацию двух предыдущих
	топологических типов.
	
	Интегральные ВВХ в этом случае определяются как в предыдущем случае, но вместо альтернативных вариантов рассматриваются альтернативные маршруты. \\
	Среднее время ожидания обслуживания в маршруте.
	\[ W = W_{i} + \sum\limits_{k = 1}^{l} \left( \beta_{k} \sum\limits_{x = 1}^{n} W_{x} \right) + W_{j} \]
	Среднее время пребывания требования в маршруте для потока \( m \).
	\[ U^{m} = U_{i}^{m} + \sum\limits_{k = 1}^{l} \left( \beta_{k} \sum\limits_{x = 1}^{n} U_{x}^{m} \right) + U_{j}^{m} \]	
	Средняя длина очереди требований в маршруте для потока \( m \).
	\[ L^{m} = L_{i}^{m} + \sum\limits_{k = 1}^{l} \left( \beta_{k} \sum\limits_{x = 1}^{n} L_{x}^{m} \right) + L_{j}^{m} \]	
	Среднее число требований в маршруте для потока \( m \).
	\[ N^{m} = N_{i}^{m} + \sum\limits_{k = 1}^{l} \left( \beta_{k} \sum\limits_{x = 1}^{n} N_{x}^{m} \right) + N_{j}^{m} \]		
\end{enumerate}

\Subsection{Вероятность выбора маршрута}
\label{subsection:pathsProbabilities}
Для вычисления интегральных ВВХ необходимо определить вероятности выбора альтернативных маршрутов (см. \ref{subsection:iptc}).

Для этого нужно учитывать вероятности перехода между узлами, заданные маршрутной матрицей \( P^{m} \) (см. \ref{subsection:routingMatrix}), и нормирующее условие
\( \sum\limits_{k = 1}^{l} \beta_{k} = 1 \), указывающее, один из маршрутов будет обязательно выбран.

Вероятность выбора маршрута определяется отношением произведения вероятностей перехода требований из узла \( M_{ R_{j}^{i} } \) в узел \( M_{ R_{j+1}^{i} } \)
\( i \) - го маршрута к сумме произведений вероятностей переходов требований всех альтернативных маршрутов (нормировочной величине).
\enlargethispage{\baselineskip}
\[ \beta_{i} = \frac{ \prod\limits_{j} P_{ R_{j}^{i}, R_{j + 1}^{i} } }{S} \]
\( S = \sum\limits_{i} \left( \prod\limits_{j} P_{ R_{j}^{i}, R_{j+1}^{i} } \right) \) - нормировочная величина. \\
\( R^{i} \) - совокупность узлов, составляющих альтернативный маршрут  \( i \). \\
\( P_{ R_{j}^{i}, R_{j+1}^{i} } \) - вероятность перехода между узлами, задаваемая маршрутной матрицей.

\Subsection{Плотность распределения количества сообщений в маршруте}
Плотность распределения количества сообщений для произвольного маршрута определяется следующим способом:
\[ g_{i} (t) = \sum\limits_{i = 1}^{n} H_{i} (\mu_{i} - \lambda_{i}^{'}) e^{ -(\mu_{i} - \lambda_{i}^{'}) t } \]
\[ H_{i} = \prod\limits_{ \substack{ j = 1 \\ j \neq i } }^{n} \frac{ \mu_{j} - \lambda_{j}^{'} }{ \mu_{j} - \lambda_{j}^{'} - \mu_{i} - \lambda_{i}^{'} } \]
где \( n \) - количество узлов в маршруте.

\Section{Определение интенсивностей обслуживающих приборов, работающих на основе технологий семейства Ethernet}
\label{section:ehernet}
Стандарт Ethernet определяет длину служебных полей кадра и преамбулу по 18 и 8 байт соответственно. От сюда следует что длина кадра в битах равна \( 8 * (X + 26), X \) - длина поля данных.
Время передачи битов кадра определяется битовыми интервалами \( bt = \frac{1}{S}, \: S \) - битовая скорость.
Для передачи кадра длиной \( X \) потребуется время равное \( 8 * (X + 26) * bt \). Прибавив межкадровый интервал \( IFG = 96 * bt \) получим
период следования кадров с длиной поля данных \( X \).
\[ T = 8 * (X + 26) * bt + IFG \]

Итенсивность обслуживания \( \mu \), которая характеризует максимальное количество кадров в секунду, обрабатываемых обслуживающим прибором, есть величина обратно пропорциональная периоду \( T \).
\[ \mu = \frac{1}{T} = \frac{1}{ 8 * (X + 26) * bt + IFG } \]

\Chapter{Программная реализация}

% -------------------------------------------- flowcharts --------------------------------------------
% Define block styles
\tikzstyle{decision} = [diamond, draw, fill=white, 
    text width=6em, text badly centered, node distance=3cm, inner sep=0pt]
\tikzstyle{sqr_block} = [rectangle, draw, fill=white, 
    text width=5em, text centered, rounded corners, minimum height=4em]
\tikzstyle{rec_block} = [rectangle, draw, fill=white,
	text width=10em, text centered, rounded corners, minimum height=2em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{cloud} = [draw, ellipse,fill=white, node distance=3cm,
    minimum height=2em]
    
\begin{figure}
	\centering
	\begin{tikzpicture}[node distance = 2cm, auto]
	    % nodes
    		\node [rec_block] (parse) { парсинг аргументов командной строки };
	    \node [decision, below of=parse, node distance=3.5cm] (log) { нужно создавать лог? };
	    \node [sqr_block, left of=log, node distance=4.5cm] (create_log) { создание файла для лога };
	    \node [rec_block, below of=log, node distance=3.5cm] (parse_config) { парсинг конфигурационного файла };
    	    \node [rec_block, below of=parse_config, node distance=2.3cm] (compute_model) { расчёт параметров модели (рис. \ref{pic:flowchart_computeModel}) };
    	    \node [decision, below of=compute_model, node distance=3.8cm] (error) { исключения при расчёте параметров? };
    	    \node [rec_block, left of=error, node distance=6.5cm] (compute_stop) { завершение вычислений };
    	    \node [rec_block, below of=compute_stop, node distance=3cm] (error_output) { вывод в консоль сообщения об ошибке, в каком месте она возникла и стэк вызовов };
    	    \node [rec_block, below of=error, node distance=3.8cm] (output) {вывод данных на консоль и, если нужно, в лог};
    	    \node [rec_block, below of=output, node distance=2.4cm] (plotting) {построение графиков плотностей (рис. \ref{pic:flowchart_graphs}) };
    		% edges
    		\path [line] (parse) -- (log);
    		\path [line] (log) -- node [near start] {да} (create_log);
    		\path [line] (log) -- node [near start] {нет} (parse_config);
    		\path [line] (create_log) |- (parse_config);
    		\path [line] (parse_config) -- (compute_model);
    		\path [line] (compute_model) -- (error);
   		\path [line] (error) -- node [near start] {да} (compute_stop);
    		\path [line] (compute_stop) -- (error_output);
   		\path [line] (error) -- node [near start] {нет} (output);
    		\path [line] (output) -- (plotting);
	\end{tikzpicture}
	
	\caption{Общая блок-схема программной реализации}
	\label{pic:flowchart_common}
\end{figure}

\begin{figure}
	\centering
	\begin{tikzpicture}[node distance = 2cm, auto]
		% nodes
		\node [rec_block] (set_stream) { установка переменной \verb:stream: значения 0 };
		\node [decision, below of=set_stream, node distance=3.5cm] (stream) {\verb:stream: < числа потоков?};
		\node [rec_block, right of=stream, node distance=5.6cm] (compute_lambda0) { вычисление уммарной интенсивности внешних источников \( \lambda_{0} \)};
		\node [rec_block, below of=compute_lambda0, node distance=3cm] (compute_input) { вычисление  входящих интенсивностей для каждого узла сети };
		\node [rec_block, below of=compute_input, node distance=3.3cm] (compute_lambdaBar) { вычисление стационарных интенсивностей потоков \( \lambda^{'} \) для каждого узла сети };
		\node [rec_block, below of=compute_lambdaBar, node distance=3.3cm] (compute_rhoBar) { вычисление коэффициентов использования \( \rho^{'} \) для каждого узла сети };
		\node [rec_block, below of=compute_rhoBar, node distance=3cm] (compute_rho) { вычисление коэффициентов загрузки \( \rho \) для каждого узла сети };
		\node[rec_block,below of=compute_rho, node distance=2.8cm] (increment_stream) {увеличение переменной \verb:stream: на 1 };
		
		\node [rec_block, left of=stream, node distance=5.6cm] (find_paths) { поиск всех путей в сети };
		\node [rec_block, below of=find_paths] (compute_sptc) { вычисление стационарных ВВХ };
		\node [rec_block, below of=compute_sptc] (compute_iptc) { вычисление интегральных ВВХ (рис. \ref{pic:flowchart_iptc}) };
		% edges
		\path [line] (set_stream) -- (stream);
		\path [line] (stream) -- node [near start] {да} (compute_lambda0);
		\path [line] (stream) -- node [near start] {нет} (find_paths);
		\path [line] (compute_lambda0) -- (compute_input);
		\path [line] (compute_input) -- (compute_lambdaBar);
		\path [line] (compute_lambdaBar) -- (compute_rhoBar);
		\path [line] (compute_rhoBar) -- (compute_rho);
		\path [line] (compute_rho) -- (increment_stream);
		\path [line] (increment_stream) -| (stream);
		\path [line] (find_paths) -- (compute_sptc);
		\path [line] (compute_sptc) -- (compute_iptc);
	\end{tikzpicture}
	
	\caption{Рассчёт параметров модели}
	\label{pic:flowchart_computeModel}
\end{figure}

\begin{figure}
	\centering
	\begin{tikzpicture}[node distance = 2cm, auto]
		% nodes
		\node [rec_block] (find_paths) { поиск всех путей между двумя заданными узлами (рис. \ref{pic:flowchart_paths}) };
		\node [rec_block, below of=find_paths, node distance=3cm] (compute_pathsProb) { вычисление вероятностей выбора для найденных маршрутов };
		\node [rec_block, below of=compute_pathsProb, node distance=3cm] (compute_iptc) { вычисление интегральных ВВХ для каждого потока };
		% edges
		\path [line] (find_paths) -- (compute_pathsProb);
		\path [line] (compute_pathsProb) -- (compute_iptc);
	\end{tikzpicture}
	
	\caption{Рассчёт интегральных ВВХ}
	\label{pic:flowchart_iptc}
\end{figure}

\begin{figure}
	\centering
	\begin{tikzpicture}[node distance = 2cm, auto]
		% nodes
		\node [decision] (paths) { начальный и конечный узлы равны? };
		\node [rec_block, right of=paths, node distance=5.5cm] (error) { выброс исключения };
		\node [rec_block, below of=paths, node distance=3.5cm] (exclude_loops) { удаляем связи начальной вершины со всеми остальными } ;
		\node [rec_block, below of=exclude_loops, node distance=2.6cm] (set_node) { установка переменной \verb:node: (промежуточный узел) значения 0 };
		\node [decision, below of=set_node, node distance=3.8cm] (node) {\verb:node: < числа узлов сети?};
		\node [rec_block, right of=node, node distance=5.2cm] (node_no) { возвращение списка найденных путей };
		\node [decision, below of=node, node distance=5.2cm] (link) { связь между \verb:node: и начальным узлом? };
		\node [rec_block, below of=link, node distance=3.7cm] (link_no) { переход на следующую итерацию };
		\node [decision, right of=link, node distance=5.3cm] (end) { \verb:node: = конечному узлу? };
		\node [rec_block, below of=end, node distance=3.6cm] (end_yes) { сохранение пути };
		\node [decision, right of=end, node distance=5.3cm] (exists) { кол-во овзвращённых путей  > 0? };
		\node [rec_block, above of=exists, node distance=4cm] (end_no) { рекурсивный вызов этой функции для промежуточного узла };
		\node [rec_block, below of=exists, node distance=3.7cm] (add) { сохранение найденных путей };
		% edges
		\path [line] (paths) -- node [near start] {нет} (exclude_loops);
		\path [line] (paths) -- node [near start] {да} (error);
		\path [line] (exclude_loops) -- (set_node);
		\path [line] (set_node) -- (node);
		\path [line] (node) -- node [near start] {нет} (node_no);
		\path [line] (node) -- node [near start] {да} (link);
		\path [line] (link) -- node [near start] {нет} (link_no);
		\path [line] (link) -- node [near start] {да} (end);
		\path [line] (end) |- node [near start] {нет} (end_no);
		\path [line] (end) -- node [near start] {да} (end_yes);
		\path [line] (end_no) -- (exists);
		\path [line] (exists) -- node [near start] {да} (add);
	\end{tikzpicture}
	
	\caption{Поиск всех путей между двумя узлами сети (одна итерация)}
	\label{pic:flowchart_paths}
\end{figure}

\begin{figure}
	\centering
	\begin{tikzpicture}[node distance = 2cm, auto]
		% nodes
		\node [rec_block] (find_paths) { поиск самого короткого и самого длинного путей в сети };
		\node [decision, below of=find_paths, node distance=3cm] (equals) { они равны? };
		\node [sqr_block, left of=equals, node distance=5.5cm] (yes) { остаётся любой из путей };
		\node [sqr_block, right of=equals, node distance=5.5cm] (no) { остаются оба пути };
		\node [rec_block, below of=equals, node distance=3.5cm] (compute_density) { вычисление плотностей распределения сообщений в маршрутах };
		\node [rec_block, below of=compute_density, node distance=2.5cm] (create_plot) { создание графика };
		\node [rec_block, below of=create_plot] (show_plot) { вывод графика на экран };
		% edges
		\path [line] (find_paths) -- (equals);
   		\path [line] (equals) -- node [near start] {да} (yes);
   		\path [line] (equals) -- node [near start] {нет} (no);
   		\path [line] (yes) |- (compute_density);
  		\path [line] (no) |- (compute_density);  		
  		\path [line] (compute_density) -- (create_plot);
		\path [line] (create_plot) -- (show_plot);
	\end{tikzpicture}
	
	\caption{Построение графиков плотностей}
	\label{pic:flowchart_graphs}
\end{figure}
% ----------------------------------------------------------------------------------------------------

\Section{Постановка задачи}
Программа должна удовлетворять следующим требованиям:
\begin{enumerate}
    \item Вычислять стационарные и интегральные ВВХ для заданной пользователем модели ИВС.
    \item Проверять корректность введённой пользователем модели ИВС.
    \item При невозможности вычисления каких-либо характеристик сообщать об этом пользователю.
\end{enumerate}

Программа будет выполнена в виде консольного приложения, т.к. этого достаточно для поставленной задачи и позволяет сконцентрироваться на реализации и достижении поставленных требований. Также это позволит программе без проблем запускаться на различных операционны системах.

\Section{Программная платформа}
Выбрана программная платформа Mono --- кроссплатформенная реализация Microsoft .Net Framework с открытым исходным кодом.
Mono поддерживает Windows, Linux, BSD, Mac OS X и другие операционные системы и множетсво процессорных платформ, что
позволяет писать переносимые приложения на C\#.
Среда разработки --- MonoDevelop.

\Section{Описание модели ИВС}
Модель ИВС одонозначно задаётся интенсивностями обслуживания \( \mu_{i}^{m} \), интенсивностями поступления сообщений
\( \lambda_{i}^{m} \) и маршрутной матрицей \( P^{m} \) для каждого входного потока \( m = \overline{1, F} \)
(см. \ref{section:mathmodel}). Таким образом надо решить как пользователь будет передавать программе описание модели ИВС.

Для этой цели используется XML файл, в котором задаются параметры модели. XML имеет простой синтаксис, удобный как для составления и чтения файлов человеком, так и для машинной обработки и генерации.

\begin{figure}[h!]
    \begin{listing}{1}
<NetworkConfiguration Name="Linear topology">
    <RoutingMatrix>
        <Row>0; -;  -;  -;  -</Row>
        <Row>0.25;  0;  0.75;   0;  0</Row>
        <Row>0.25;  0.375;  0;  0.375;  0</Row>
        <Row>0.25;  0;  0.375;  0;  0.375</Row>
        <Row>0.25;  0;  0;  0.75;   0</Row>
    </RoutingMatrix>
        
    <Nodes Count="4">
        <Lambda>17; 14; 13; 16</Lambda>
		        
        <Mu>
            <Ethernet Type="Gigabit" FrameLength="Max"/>
        </Mu>
    </Nodes>
</NetworkConfiguration>\end{listing}
    
    \caption{Описание ИВС линейной топологии из 4-х узлов и одним потоком}
    \label{pic:xml}
\end{figure}

На рис. \ref{pic:xml} показан XML файл, задайющий модель ИВС, состоящей из 4-х узлов с линейной топологией и единственным потоком.

Интенсивность обслуживания \( \mu \) задаётся для пакетов максимальной длины технологии Gigabit Ethernet (пакеты/мс), интенсивность поступления сообщений \( \lambda \) задаётся в явном виде для каждого узла сети (пакеты/мс).
\[ \mu = (81.3, 81.3, 81.3, 81.3), \: \lambda = (17, 14, 13, 16) \]

Со 2-й по 8-ю строки задаётся маршрутная матрица.
\[ P = \left(\begin{matrix}
                0 & - & - & - & - \\
                0.25 & 0 & 0.75 & 0 & 0 \\
                0.25 & 0.375 & 0 & 0.375 & 0 \\
                0.25 & 0 & 0.375 & 0 & 0.375 \\
                0.25 & 0 & 0 & 0.75 & 0 \\
            \end{matrix}\right) \]
Прочерки в строках задаваемой матрицы указывают программе, что надо вычислить соответствующие вероятности. В данном случае
будут вычисляться вероятности поступления сообщений из внешнего источника.

За более подробной информацией о структуре файла обращайтесь к Приложению \ref{appendix:xml}.
            
Разбор XML файла осуществляется с помощью стандартных средств языка C\# из пространств имён System.Xml и System.Xml.Linq.
            
%\Section{Вычисление вероятностей поступления сообщений из внешнего источника}
%Вероятность поступления сообщений из внешнего источника в узел сети \( M_{i} \) для потока \( m \) есть отношение интенсивности поступления сообщений из внешнего источника в узел \( M_{i} \) к суммарной интенсивности внешнего источника.
%\[ P_{0i}^{m} = \frac{\lambda_{i}^{m}}{\lambda_{0}^{m}}, \: \lambda_{0}^{m} = \sum\limits_{i = 1}^{n} \lambda_{i}^{m} \]
%
%\noindent В программной реализации это выглядит следующим образом:
%\begin{verbatim}
%InputIntensity[stream] = Lambda[stream].Divide(Lambda0[stream]);
%\end{verbatim}
%Где: \\
%\verb:stream: - переменная, определяющая поток. \\
%\verb:InputIntensity: - массив векторов, хранящий вероятности поступления сообщений от внешнего источника для каждого потока. \\
%\verb:Lambda[stream]: - вектор интенсивностей \( \lambda^{m} \). \\
%\verb:Lambda0[stream]: - суммарная интенсивность внешнего источника. \\
%\verb:.Divide(): - поэлементное деление вектора на число.
%
%\Section{Составление и решение уравнений баланса}
%Расширенная матрица системы уравнений баланса получается из матрицы маршрутизации следующим способом:
%\begin{enumerate}
%    \item Транспонируем матрицу маршрутизации.
%    \item Вычёркиваем нулевую строчку.
%    \item Умножаем нулевой столбец на \( -1 \).
%    \item Переносим нулевой столбец в конец.
%    \item Проставляем \( -1 \) на главной диагонали.
%\end{enumerate}
%
%Получаем расширенную матрицу для системы уравнений следующего вида и решаем её с помощью матода Гаусса:
%\[
% 	\left\{
%		\begin{aligned}
%			& -e_{1}^{m} + e_{1}^{m} P_{11}^{m} + \cdots + e_{n}^{m} P_{n1}^{m} = -P_{01}^{m} \\
%			& \vdots \\
%			& -e_{n}^{m} + e_{1}^{m} P_{1n}^{m} + \cdots + e_{n}^{m} P_{nn}^{m} = -P_{0n}^{m}
%		\end{aligned}
%	\right.
%\]
%
%\begin{figure}
%    \begin{listing}{1}
%private Matrix<double> GetExtendedMatrix(int streamIndex)
%{
%	var matrix = GetRoutingMatrix(streamIndex);
%	matrix.Transpose();
%	matrix.RemoveRow(0);
%	matrix.AddColumn(matrix.GetColumn(0).Negate());
%	matrix.RemoveColumn(0);
%	matrix.ReplaceDiagonalElements(-1);
%
%	return matrix;
%}\end{listing}
%    
%    \caption{Функция преобразования мартрицы маршрутизации в расширенную матрицу системы уравнений баланса}
%    \label{pic:functions_getextendedmatrix}
%\end{figure}
%
%В программной реализации (рис. \ref{pic:functions_getextendedmatrix}) вызывается функция \verb:GetRoutingMatrix:, возвращающая матрицу маршрутизации для заданного потока и преоразует её в соответствии с представленным алгоритмом.
%\clearpage
%
%\Section{Вычисление общих интенсивностей потоков}
%Вычисления общих интенсивностей потоков \( \lambda_{i}^{'m} \) (\ref{subsection:balanceEquations}) в программной реализации имеет следующий вид:
%\begin{verbatim}
%LambdaBar[stream] = E[stream].Multiply(Lambda0[stream]);
%\end{verbatim}
%Где: \\
%\verb:E[stream]: - вектор значений коэффициентов передачи \( e_{i}^{m} \) для потока \( m =  \) \verb:stream:,
%полученные при решении системы уравнений баланса. \\
%\verb:Lambda0[stream]: - значениt суммарной интенсивности всех внешних потоков типа \( m =  \) \verb:stream:. \\
%\verb:.Multiply(): - поэлементное деление вектора на число.
%
%\Section{Вычисление коэффициентов загрузки}
%В соответствии с формулами из \ref{subsection:coefficientOfLoading} коэффициент загрузки вычисляется следующим образом:
%\begin{verbatim}
%RoTotal = RoTotal.AddElementWise(RoBar.Last());
%\end{verbatim}
%Где: \\
%\verb:RoBar[stream] = LambdaBar[stream].DivideElementWise(Mu[stream]): - вектор коэффициентов использования \( \rho_{i}^{m}, m =  \) \verb:stream:.
%
%\Section{Вычисление стационарных ВВХ}
%\begin{figure}[h!]
%	\begin{listing}{1}
%private void ComputeStationaryPTC()
%{
%	for (int i = 0; i < NodesCount; i++)
%	{
%		double sum = 0.0;
%		for (int stream = 0; stream < StreamsCount; stream++)
%		sum += RoBar[stream][i] / Mu[stream][i];
%
%		Ws.AddElement(sum / (1 - RoTotal[i]));
%	}
%
%	for (int stream = 0; stream < StreamsCount; stream++)
%	{
%		Us.Add( Ws.AddElementWise(Mu[stream].Pow( -1 )) );
%		Ls.Add( LambdaBar[stream].MultiplyElementWise( Ws ) );
%		Ns.Add( LambdaBar[stream].MultiplyElementWise( Us[stream]) );
%	}
%}
%	\end{listing}
%\end{figure}
%
%\Section{Вычисление интегральных ВВХ}
%
%
%\Section{Как использовать программу}
%Для использования программы

\Chapter{Модельный эксперимент}

\chapter*{\centering Заключение}
\addcontentsline{toc}{chapter}{Заключение}

\begin{appendices}
    \chapter{Структура XML файла для описания модели ИВС}
    \label{appendix:xml}
\end{appendices}

\renewcommand{\bibname}{\centering Список литературы}
\begin{thebibliography}{00}
\addcontentsline{toc}{chapter}{Список литературы}

\bibitem{barashin} Барашин Г.П., Харкевич А.Д., Шнепс М.А.
Массовое обслуживание в телефонии.
--- Москва: Издательство <<Наука>>, 1968.
--- 246 с.

\bibitem{vishnevsky} Вишневский В.М.
Теоретические основы проектирования компьютерных сетей: монография.
--- Москва: Техносфера, 2003.
--- 512 с.

\bibitem{kleinrock:smfad} Клейнрок Л.
Коммуникационные сети (стохастические потоки и задержки сообщений).
--- Москва: Главная редакция физико-математической литературы изд-ва <<Наука>>, 1970.
--- 256 с.

\bibitem{kleinrock:qs} Клейнрок Л.
Теория массового обслуживания.
--- Москва: Машиностроение, 1979.
--- 432 с.

\bibitem{kleinrock:ca} Клейнрок Л.
Вычислительные системы с очередями.
--- Москва: Издательство <<Мир>>, 1979.
--- 600 с.

\bibitem{klimanov:thesis} Климанов В.П.
Методология анализа вероятностно-временных характеристик локальных вычислительных сетей составных топологий на основе аналитического
моделирования: автореферат диссертации на соискание учёной степени доктора технических наук.
--- Москва: Московский энергетический институт, 1993.
--- 40 с.

\bibitem{klimanov:manual} Климанов В.П., Руделёв Р.А.
Моделирование информационных систем. Математические модели для разработки информационных систем: методика и решения: учебное пособие.
--- Москва: ФГБОУ ВПО МГТУ <<СТАНКИН>>, 2014.
--- 45 с.

\bibitem{cox} Кокс Д.Р., Смит У.Л.
Теория очередей.
--- Москва: Издательство <<Мир>>, 1966.
--- 218 с.

\bibitem{olifers} Олифер В.Г., Олифер Н.А.
Компьютерные сети. Принципы, технологии, протоколы: учебник для вузов.
--- 4-е изд.
--- Санкт-Петербург: Питер, 2010.
--- 944 с.

\bibitem{pisarev} Писарев В.Н.
Применение теории массового обслуживания в задачах инженерно-авиационного обеспечения.
--- Типография ВВИА имени проф. Н.Е. ~Жукова, 1965.
--- 45 с.

\bibitem{tanenbaum} Таненбаум Э., Уезеролл Д.
Компьютерные сети.
--- 5-е изд.
--- Санкт-Петербург: Питер, 2012.
--- 960 с.

\bibitem{hinchin} Хинчин А.Я.
Работы по математической теории массового обслуживания
--- Москва: Физматгиз, 1963.
--- 236 с.

\end{thebibliography}
\end{document}